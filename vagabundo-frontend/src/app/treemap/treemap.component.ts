import { Component, ViewEncapsulation, Input, ElementRef, OnChanges, SimpleChanges } from '@angular/core';
import { TreemapData } from './treemap-data';

import * as d3Selection from 'd3-selection';
import * as d3Scale from 'd3-scale';
import * as d3Hierarchy from 'd3-hierarchy';

/**
 * Visualizes a treemap, i.e. a rectangular element containing multiple blocks. The blocks are different in size
 * and color, respective to their value.
 *
 * To use it include it in a template with:
 *     <treemap [data]="treemapData"></treemap>
 *
 * and treemapData being an object of class {@link TreemapData}.
 *
 * The following optional attributes can be set:
 * <ul>
 *     <li><b>width:</b> width of the whole component in pixel</li>
 *     <li><b>height:</b> height of the whole component in pixel</li>
 *     <li><b>colorRange</b> array of colors hex values in which the treemap will be colored. The number of colors can
 *                           be as large as you want and will be mapped automatically evenly</li>
 * </ul>
 *
 * By default it will be colored in Senacor brand colors.
 *
 * This component uses D3. Hence, for now we have to use ViewEncapsulation.None (i.e. the css is basically
 * but in the global css) as D3 generates HTML without Angulars knowledge and the default emulated view encapsulation
 * relies on Angular preprocessing the css to rename it - However, the HTML generated by D3 does not know anything
 * about this preprocessing. Another possibility to circumvent this would be to shadow-piercing descendant combinators
 * (e.g. by using /deep/, >>> or ::ng-deep), but this is deprecated by major browsers.
 */
@Component({
  selector: 'app-treemap',
  encapsulation: ViewEncapsulation.None,
  templateUrl: './treemap.component.html',
  styleUrls: ['./treemap.component.scss']
})
export class TreemapComponent implements OnChanges {

  constructor(myElement: ElementRef) {
    this.componentSelection = d3Selection.select(myElement.nativeElement);
  }
  @Input() data: TreemapData;
  @Input() width = 1200;
  @Input() height = 500;
  @Input() colorRange: string[] = ['#059E7F', '#0C4650'];

  /** Component element selection. */
  private componentSelection: any;
  /** SVG node. Inside this element everything is drawn. */
  private svg: d3Selection.Selection<SVGElement, {}, HTMLElement, any>;
  /** Color scale for the treemap boxes. */
  private colorScale: d3Scale.ScaleLinear<String, String>;
  /** Treemap layout. */
  private treemapLayout: d3Hierarchy.TreemapLayout<any>;
  /** The root node selection for the treemap representing the hierarchy. Holds as children the data for all boxes to be displayed. */
  private hierarchyNodes: d3Hierarchy.HierarchyRectangularNode<TreemapData>;
  /** Nodes to visualize the treemap boxes. */
  private nodes: any;
  /** The treemap is loaded and at least one dataset is inside. */
  public showTreemap = false;
  /** We loaded data, but there simply is not data to display. Show error message instead. */
  public showNoData = false;

  /**
   * Based on the color range we want to map the domain accordingly and evenly to our data, i.e. the first color should
   * map to the lowest treemap value and the last color should map to the highest treemap value and all
   * other values in between.
   * @param hierarchyNodes hierarchy nodes
   * @param range color range as hex strings
   */
  private static getColorDomain(hierarchyNodes: d3Hierarchy.HierarchyNode<TreemapData>, range: string[]): number[] {
    const colorDomain: number[] = [];
    if (hierarchyNodes.children !== undefined && hierarchyNodes.children.length > 0) {
      const diff: number = Math.max((hierarchyNodes.children.length / (range.length - 1)) - 1, 0);

      for (let i = 0; i < range.length; ++i) {
        const pos: number = Math.floor(i * diff);
        colorDomain[i] = hierarchyNodes.children[pos].value;
      }
    }
    return colorDomain;
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes.data !== undefined && changes.data.isFirstChange()) {
      this.init();
    }
    if (changes.data !== undefined && changes.data.currentValue !== undefined &&
      changes.data.currentValue !== null) {
      this.data = changes.data.currentValue;
      this.drawNodes();
    }
  }

  /**
   * Initializes basic layout and data binding. Sets up the SVG element, the treemap layout, color range and
   * flattens the hierarchy data.
   */
  private init(): void {
    this.svg = this.componentSelection.select('svg')
      .append('g');

    this.treemapLayout = d3Hierarchy.treemap()
      .size([this.width, this.height])
      .paddingOuter(0);
  }

  /**
   * Draws the treemap boxes and the text within.
   */
  private drawNodes(): void {
    this.svg.selectAll('*').remove();

    this.hierarchyNodes = this.treemapLayout(d3Hierarchy.hierarchy(this.data)
      .sum(d => d.value)
      .sort((a, b) => b.value - a.value));

    this.colorScale = d3Scale.scaleLinear<String>()
      .domain(TreemapComponent.getColorDomain(this.hierarchyNodes, this.colorRange))
      .range(this.colorRange);

    const dataToDisplay = this.hierarchyNodes.descendants().filter(f => {
      return f.data.value > 0;
    });

    this.nodes = this.svg
      .selectAll('g')
      .data(dataToDisplay)
      .enter()
      .append('g')
      .attr('transform', (d: d3Hierarchy.HierarchyRectangularNode<any>) => 'translate(' + [d.x0, d.y0] + ')');

    this.nodes
      .append('rect')
      .attr('width', d => d.x1 - d.x0)
      .attr('height', d => d.y1 - d.y0)
      .attr('fill', d => this.colorScale(d.value));

    this.nodes
      .append('text')
      .attr('dx', 4)
      .attr('dy', 14)
      .text(d => d.data.name);

    this.nodes
      .append('text')
      .attr('dx', 4)
      .attr('dy', 30)
      .text(d => d.data.value.toLocaleString('de-DE', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }) + ' kg');

    this.setVisibility(dataToDisplay);
  }

  /**
   * Sets the visibility of the treemap and error messages based on whether there is actually data to show.
   * @param dataToDisplay data nodes
   */
  private setVisibility(dataToDisplay: any[]): void {
    if (dataToDisplay.length === 0) {
      this.showNoData = true;
      this.showTreemap = false;
    } else {
      this.showNoData = false;
      this.showTreemap = true;
    }
  }
}
